/*
 * Combined test main.c:
 * - BLE Vendor service (abcdef1) Indication @ 1Hz (only when CCC enabled)
 * - LSM6DSO: I2C scan + accel/gyro log (thread)
 */

#include <zephyr/kernel.h>
#include <zephyr/logging/log.h>
#include <zephyr/sys/byteorder.h>

#include <zephyr/device.h>
#include <zephyr/drivers/i2c.h>
#include <zephyr/drivers/sensor.h>

#include <zephyr/settings/settings.h>
#include <zephyr/sys/printk.h>

#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/hci.h>
#include <zephyr/bluetooth/uuid.h>
#include <zephyr/bluetooth/gatt.h>

LOG_MODULE_REGISTER(main, LOG_LEVEL_INF);

/* ---------- Vendor UUIDs (abcdef0 service, abcdef1 indicate char) ---------- */
#define BT_UUID_CUSTOM_SERVICE_VAL \
	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef0)

static const struct bt_uuid_128 vnd_uuid = BT_UUID_INIT_128(BT_UUID_CUSTOM_SERVICE_VAL);

static const struct bt_uuid_128 vnd_ind_uuid = BT_UUID_INIT_128(
	BT_UUID_128_ENCODE(0x12345678, 0x1234, 0x5678, 0x1234, 0x56789abcdef1));

#define VND_MAX_LEN 20
static uint8_t vnd_value[VND_MAX_LEN + 1] = { 'V', 'e', 'n', 'd', 'o', 'r', 0 };

static void lsm6dso_read_whoami(void)
{
    const struct device *i2c = DEVICE_DT_GET(DT_NODELABEL(i2c0));
    uint8_t who = 0;

    if (!device_is_ready(i2c)) {
        LOG_ERR("I2C0 not ready");
        return;
    }

    int ret = i2c_reg_read_byte(i2c, 0x6A, 0x0F, &who);  // 0x6A = SDO=GND일 때 주소
    if (ret) {
        LOG_ERR("WHO_AM_I read failed: %d", ret);
        return;
    }

    LOG_INF("LSM6D* WHO_AM_I = 0x%02X (LSM6DSO expected: 0x6C)", who);
}

/* ---------- GATT read/write for the characteristic value (optional) ---------- */
static ssize_t read_vnd(struct bt_conn *conn, const struct bt_gatt_attr *attr,
			void *buf, uint16_t len, uint16_t offset)
{
	const char *value = attr->user_data;
	return bt_gatt_attr_read(conn, attr, buf, len, offset, value, strlen(value));
}

static ssize_t write_vnd(struct bt_conn *conn, const struct bt_gatt_attr *attr,
			 const void *buf, uint16_t len, uint16_t offset,
			 uint8_t flags)
{
	uint8_t *value = attr->user_data;

	if (offset + len > VND_MAX_LEN) {
		return BT_GATT_ERR(BT_ATT_ERR_INVALID_OFFSET);
	}

	memcpy(value + offset, buf, len);
	value[offset + len] = 0;
	return len;
}

/* ---------- Indication control ---------- */
static uint8_t simulate_vnd;   /* CCC indicates enabled? */
static uint8_t indicating;     /* waiting for ACK? */
static struct bt_gatt_indicate_params ind_params;
static uint8_t ind_data[5];    /* [0]=cnt, [1..4]=timestamp(le32) */

static void vnd_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value)
{
	simulate_vnd = (value == BT_GATT_CCC_INDICATE) ? 1 : 0;
	LOG_INF("Indication %s", simulate_vnd ? "ENABLED" : "DISABLED");
}

static void indicate_cb(struct bt_conn *conn,
			struct bt_gatt_indicate_params *params,
			uint8_t err)
{
	ARG_UNUSED(conn);
	ARG_UNUSED(params);

	indicating = 0U;
	if (err) {
		LOG_WRN("Indication failed (err=%u)", err);
	} else {
		LOG_INF("Indication ACK");
	}
}

/* ---------- Vendor Primary Service ---------- */
BT_GATT_SERVICE_DEFINE(vnd_svc,
	BT_GATT_PRIMARY_SERVICE(&vnd_uuid),
	BT_GATT_CHARACTERISTIC(&vnd_ind_uuid.uuid,
			       BT_GATT_CHRC_READ | BT_GATT_CHRC_WRITE | BT_GATT_CHRC_INDICATE,
			       BT_GATT_PERM_READ | BT_GATT_PERM_WRITE,
			       read_vnd, write_vnd, vnd_value),
	BT_GATT_CCC(vnd_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),
);

/* ---------- Advertising ---------- */
static const struct bt_data ad[] = {
	BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
	BT_DATA_BYTES(BT_DATA_UUID128_ALL, BT_UUID_CUSTOM_SERVICE_VAL),
};

static const struct bt_data sd[] = {
	BT_DATA(BT_DATA_NAME_COMPLETE, CONFIG_BT_DEVICE_NAME,
		sizeof(CONFIG_BT_DEVICE_NAME) - 1),
};

/* ---------- Indication Work (1Hz) ---------- */
static void vnd_indicate_work_handler(struct k_work *work);
K_WORK_DELAYABLE_DEFINE(vnd_indicate_work, vnd_indicate_work_handler);

static void vnd_indicate_work_handler(struct k_work *work)
{
	ARG_UNUSED(work);

	/* Only send if enabled and not waiting for ACK */
	if (simulate_vnd && !indicating) {
		static uint8_t cnt;
		ind_data[0] = cnt++;
		sys_put_le32(k_uptime_get_32(), &ind_data[1]);

		ind_params.attr = &vnd_svc.attrs[1]; /* characteristic VALUE attr */
		ind_params.func = indicate_cb;
		ind_params.data = ind_data;
		ind_params.len  = sizeof(ind_data);

		int err = bt_gatt_indicate(NULL, &ind_params);
		if (err == 0) {
			indicating = 1U;
			LOG_INF("Indicate sent: cnt=%u ts=%u", ind_data[0], sys_get_le32(&ind_data[1]));
		} else {
			LOG_WRN("bt_gatt_indicate err=%d", err);
		}
	}

	k_work_schedule(&vnd_indicate_work, K_SECONDS(1));
}

/* ---------- IMU: I2C scan + LSM6DSO thread ---------- */
static void i2c_scan_bus(void)
{
	const struct device *i2c = DEVICE_DT_GET(DT_NODELABEL(i2c0));

	if (!device_is_ready(i2c)) {
		LOG_ERR("I2C0 not ready");
		return;
	}

	LOG_INF("I2C scan start (i2c0)...");
	for (uint8_t addr = 0x03; addr <= 0x77; addr++) {
		struct i2c_msg msg = {
			.buf = NULL,
			.len = 0,
			.flags = I2C_MSG_WRITE | I2C_MSG_STOP,
		};

		if (i2c_transfer(i2c, &msg, 1, addr) == 0) {
			LOG_INF("  Found device at 0x%02X", addr);
		}
	}
	LOG_INF("I2C scan done.");
}

#define IMU_STACK_SIZE 2048
#define IMU_THREAD_PRIO 7
K_THREAD_STACK_DEFINE(imu_stack, IMU_STACK_SIZE);
static struct k_thread imu_thread;

static void imu_thread_entry(void *p1, void *p2, void *p3)
{
	ARG_UNUSED(p1); ARG_UNUSED(p2); ARG_UNUSED(p3);

	const struct device *imu = DEVICE_DT_GET(DT_ALIAS(imu0));

	if (!device_is_ready(imu)) {
		LOG_ERR("LSM6DSO not ready. Check overlay + wiring + CONFIG_LSM6DSO");
		return;
	}
	 /* Set ODR (sampling frequency) - often fixes 'all zeros' */
        struct sensor_value odr = { .val1 = 104, .val2 = 0 };  /* 104 Hz */
        int ret;

        ret = sensor_attr_set(imu, SENSOR_CHAN_ACCEL_XYZ,
                          SENSOR_ATTR_SAMPLING_FREQUENCY, &odr);
        if (ret) {
       	    LOG_WRN("ACC ODR set failed: %d", ret);
        }

        ret = sensor_attr_set(imu, SENSOR_CHAN_GYRO_XYZ,
                          SENSOR_ATTR_SAMPLING_FREQUENCY, &odr);
        if (ret) {
            LOG_WRN("GYR ODR set failed: %d", ret);
        }
	LOG_INF("LSM6DSO ready! Reading accel/gyro...");
	while (1) {
	    struct imu_sample sample = {0};

            /* Fetch */
            ret = sensor_sample_fetch(imu);
            if (ret) {
                LOG_WRN("sensor_sample_fetch failed: %d", ret);
                k_msleep(200);
                continue;
            }

            /* Read channels (split X/Y/Z for robustness) */
            struct sensor_value ax, ay, az;
            struct sensor_value gx, gy, gz;

            sensor_channel_get(imu, SENSOR_CHAN_ACCEL_X, &ax);
	    if (ret) LOG_WRN("ACC_X get failed: %d", ret);
            sensor_channel_get(imu, SENSOR_CHAN_ACCEL_Y, &ay);
	    if (ret) LOG_WRN("ACC_Y get failed: %d", ret)
            sensor_channel_get(imu, SENSOR_CHAN_ACCEL_Z, &az);
            if (ret) LOG_WRN("ACC_Z get failed: %d", ret);

            sensor_channel_get(imu, SENSOR_CHAN_GYRO_X, &gx);
	    if (ret) LOG_WRN("GYR_X get failed: %d", ret);
            sensor_channel_get(imu, SENSOR_CHAN_GYRO_Y, &gy);
	    if (ret) LOG_WRN("GYR_Y get failed: %d", ret);
            sensor_channel_get(imu, SENSOR_CHAN_GYRO_Z, &gz);
	    if (ret) LOG_WRN("GYR_Z get failed: %d", ret);
            /* Convert to int16-ish scaled values for queue
           (simple: keep val1 only; later i can scale properly) */
            sample.accel_x = (int16_t)ax.val1;
            sample.accel_y = (int16_t)ay.val1;
            sample.accel_z = (int16_t)az.val1;

            sample.gyro_x = (int16_t)gx.val1;
            sample.gyro_y = (int16_t)gy.val1;
            sample.gyro_z = (int16_t)gz.val1;

            sample.timestamp = k_uptime_get_32();

            /* Push to queue */
            if (k_msgq_put(&sample_queue, &sample, K_NO_WAIT) != 0) {
                LOG_WRN("Sample queue full");
            }

            /* Log (throttle if too spammy later) */
            LOG_INF("ACC: x=%d.%06d y=%d.%06d z=%d.%06d | GYR: x=%d.%06d y=%d.%06d z=%d.%06d",
                ax.val1, ax.val2, ay.val1, ay.val2, az.val1, az.val2,
                gx.val1, gx.val2, gy.val1, gy.val2, gz.val1, gz.val2);

            k_msleep(200); /* 100 Hz loop-ish */	
	}
}

/* ---------- BLE connection logs ---------- */
static void connected(struct bt_conn *conn, uint8_t err)
{
	if (err) {
		LOG_WRN("Connection failed (err 0x%02x)", err);
	} else {
		LOG_INF("Connected");
	}
}

static void disconnected(struct bt_conn *conn, uint8_t reason)
{
	ARG_UNUSED(conn);
	LOG_INF("Disconnected (reason 0x%02x)", reason);
}

BT_CONN_CB_DEFINE(conn_callbacks) = {
	.connected = connected,
	.disconnected = disconnected,
};

int main(void)
{
	LOG_INF("Boot: BLE + LSM6DSO test");

	/* IMU part */
	i2c_scan_bus();
	lsm6dso_read_whoami();
	k_msleep(2000);
	k_thread_create(&imu_thread, imu_stack,
			K_THREAD_STACK_SIZEOF(imu_stack),
			imu_thread_entry,
			NULL, NULL, NULL,
			IMU_THREAD_PRIO, 0, K_NO_WAIT);

	/* BLE part */
	int err = bt_enable(NULL);
	if (err) {
		LOG_ERR("Bluetooth init failed (err %d)", err);
		return 0;
	}
	LOG_INF("Bluetooth initialized");

	if (IS_ENABLED(CONFIG_SETTINGS)) {
		settings_load();
	}

	err = bt_le_adv_start(BT_LE_ADV_CONN_FAST_1, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd));
	if (err) {
		LOG_ERR("Advertising failed to start (err %d)", err);
		return 0;
	}
	LOG_INF("Advertising started");

	/* start 1Hz indication scheduler */
	k_work_schedule(&vnd_indicate_work, K_SECONDS(1));

	while (1) {
		k_sleep(K_SECONDS(1));
	}
	return 0;
}
